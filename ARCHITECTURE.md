# 系统架构说明

## 整体架构

```
┌────────────────────────────────────────────────────────────────┐
│                       RDMA发送端                                │
│                    (数据源，如望远镜)                           │
└───────────────────────────┬────────────────────────────────────┘
                            │ RoCE v2 / InfiniBand
                            │ (高速网络传输)
                            ↓
┌────────────────────────────────────────────────────────────────┐
│                   本地接收系统 (rdma_dada)                      │
│                                                                  │
│  ┌────────────────────────────────────────────────────────┐   │
│  │  1. RDMA接收器 (Demo_psrdada_online)                  │   │
│  │     - 初始化RDMA资源                                   │   │
│  │     - 轮询完成队列(CQ)                                 │   │
│  │     - 累积批次数据                                     │   │
│  └──────────────────────┬─────────────────────────────────┘   │
│                         │ 写入内存                             │
│                         ↓                                      │
│  ┌────────────────────────────────────────────────────────┐   │
│  │  2. PSRDADA Ring Buffer                               │   │
│  │     - 共享内存环形缓冲                                 │   │
│  │     - 多进程同步访问                                   │   │
│  │     - Block级别管理                                    │   │
│  └──────────────────────┬─────────────────────────────────┘   │
│                         │ 读取数据                             │
│                         ↓                                       │
│  ┌────────────────────────────────────────────────────────┐   │
│  │  3. 数据写盘器 (dada_dbdisk)                          │   │
│  │     - 读取ring buffer块                               │   │
│  │     - 写入.dada文件                                    │   │
│  │     - 自动文件切换                                     │   │
│  └────────────────────────────────────────────────────────┘   │
└────────────────────────────────────────────────────────────────┘
                            │
                            ↓
                    ┌───────────────┐
                    │  磁盘文件     │
                    │  *.dada       │
                    └───────────────┘
```

## 数据流详解

### 阶段1: RDMA接收 → Ring Buffer

```
RDMA网络包
    ↓
┌─────────────────────────────────────┐
│ RDMA接收线程 (SendRecvThread)      │
│                                     │
│ 1. ibv_poll_cq() - 轮询完成队列    │
│    └→ 获取到达的包                 │
│                                     │
│ 2. 累积到批次大小                  │
│    └→ 等待 send_n 个包             │
│                                     │
│ 3. 检查当前block空间               │
│    └→ 不足则请求新block            │
│                                     │
│ 4. memcpy到ring buffer             │
│    └→ 拷贝 send_n × pkt_size      │
│                                     │
│ 5. 更新写入计数                    │
│    └→ 递减剩余写入次数             │
│                                     │
│ 6. block满时标记已写入             │
│    └→ MarkWritten()                │
└─────────────────────────────────────┘
```

### 阶段2: Ring Buffer内部结构

```
PSRDADA Ring Buffer (共享内存)
┌────────────────────────────────────────────────────┐
│  Header Block (控制信息)                            │
│  - 魔数标记                                         │
│  - Block数量、大小                                  │
│  - 读写指针                                         │
│  - 同步标志                                         │
└────────────────────────────────────────────────────┘
┌────────────────────────────────────────────────────┐
│  Data Block 0   ← 写入者当前位置                   │
│  [FULL] 已写入，等待读取                           │
└────────────────────────────────────────────────────┘
┌────────────────────────────────────────────────────┐
│  Data Block 1   ← 读取者当前位置                   │
│  [READING] 正在被dada_dbdisk读取                   │
└────────────────────────────────────────────────────┘
┌────────────────────────────────────────────────────┐
│  Data Block 2                                      │
│  [EMPTY] 空闲，可供写入                            │
└────────────────────────────────────────────────────┘
┌────────────────────────────────────────────────────┐
│  ...                                               │
│  (NBUFS - 3个其他blocks)                          │
└────────────────────────────────────────────────────┘
```

### 阶段3: Ring Buffer → 磁盘文件

```
┌─────────────────────────────────────┐
│ dada_dbdisk进程                    │
│                                     │
│ 1. ipcbuf_get_next_read()          │
│    └→ 等待新的已写入block          │
│                                     │
│ 2. 读取block数据                   │
│    └→ 从共享内存读取               │
│                                     │
│ 3. 写入.dada文件                   │
│    └→ ASCII header + 二进制数据    │
│                                     │
│ 4. 文件大小达到限制                │
│    └→ 关闭当前文件，创建新文件     │
│                                     │
│ 5. ipcbuf_mark_cleared()           │
│    └→ 标记block为已读，供写入者重用│
└─────────────────────────────────────┘
```

## 关键组件交互

### 1. 写入者锁定ring buffer

```cpp
// Demo_psrdada_online.cpp
PsrdadaRingBuf::Init() {
    // 连接到共享内存
    hdu = dada_hdu_open(header);
    
    // 锁定为写入者
    dada_hdu_lock_write(hdu);
    
    // 获取buffer指针
    ipcbuf = hdu->data_block;
}
```

### 2. 获取可写block

```cpp
GetBuffPtr(long int& buf_size) {
    // 请求下一个可写block
    char* ptr = ipcbuf_get_next_write(ipcbuf);
    
    // 返回block大小
    buf_size = ipcbuf_get_bufsz(ipcbuf);
    
    return ptr;
}
```

### 3. 标记block已写入

```cpp
SendBuffPtr() {
    // 标记当前block已填充完成
    ipcbuf_mark_filled(ipcbuf, block_size);
    
    // 通知读取者可以读取
}
```

### 4. 读取者读取数据

```bash
# dada_dbdisk自动执行：
# 1. 等待已写入的block
# 2. 读取block数据
# 3. 写入文件
# 4. 标记block为已读
dada_dbdisk -k 0xdada -D ./data_out -o -z
```

## 同步机制

### 信号量保护

```
写入者 (Demo_psrdada_online)        读取者 (dada_dbdisk)
        │                                    │
        ├─ Lock Write ─────────────────────→│ 等待
        │                                    │
        ├─ GetNextWrite ───────────────────→│ 等待
        │                                    │
        ├─ [写入数据...]                     │ 等待
        │                                    │
        ├─ MarkFilled ─────────────────────→│ 唤醒
        │                                    │
        │ 等待 ←──────────────── GetNextRead ┤
        │                                    │
        │ 等待                    [读取数据...]┤
        │                                    │
        │ 唤醒 ←──────────────── MarkCleared ┤
        │                                    │
        └─ GetNextWrite ───────────────────→│ 等待
                (循环继续...)
```

### EOD (End of Data) 信号

```
发送者完成 → 发送EOD标记 → Ring Buffer设置EOD标志
                               │
                               ↓
                          读取者检测EOD
                               │
                               ↓
                          完成当前文件
                               │
                               ↓
                          关闭文件并退出
```

## 内存管理

### 连续内存模式 (最优性能)

```
┌────────────────────────────────────────────────────┐
│  完整Ring Buffer (连续的虚拟地址空间)              │
│  ┌──────┬──────┬──────┬──────┬──────┐            │
│  │Block0│Block1│Block2│Block3│Block4│ ... NBUFS  │
│  └──────┴──────┴──────┴──────┴──────┘            │
│                                                    │
│  注册为单个MR (Memory Region)                     │
│  └→ DMA可以直接写入任意block                      │
└────────────────────────────────────────────────────┘

优势：零拷贝，DirectToRing模式
```

### 非连续内存模式 (兼容性)

```
Ring Buffer分散在多个物理页
┌──────┐    ┌──────┐    ┌──────┐
│Block0│    │Block1│    │Block2│ ...
└──────┘    └──────┘    └──────┘
   MR0         MR1         MR2

每个block独立注册为MR
└→ DMA写入内部缓冲区，然后memcpy到block

劣势：需要额外拷贝，但保证兼容性
```

## 性能优化点

1. **批处理**: 累积多个包后一次性处理
2. **预分配**: Ring buffer预先分配，避免运行时分配
3. **零拷贝**: 连续内存时直接DMA写入
4. **异步处理**: 写入和读取并行进行
5. **Block级同步**: 减少锁竞争，提高并发

## 错误恢复

```
┌─────────────────┐
│  检测到错误     │
└────────┬────────┘
         │
         ├─→ RDMA错误 ──→ 重置CQ，重新post_recv
         │
         ├─→ Buffer满 ──→ 等待读取者释放空间
         │
         ├─→ 空间不足 ──→ 自动请求新block (v1.2.0)
         │
         └─→ 其他错误 ──→ 记录日志，优雅退出
```

## 配置优化建议

### Ring Buffer大小选择

```
总大小 = block_size × NBUFS

建议：
- NBUFS ≥ 8 (至少8个block做缓冲)
- block_size = 批次大小 × N (N为整数，如256)
- 总大小 ≤ kernel.shmmax (系统限制)

示例配置：
- 批次: 528,384 字节
- block: 528,384 × 256 = 135 MB
- NBUFS: 8
- 总大小: 135 × 8 = 1080 MB ✅
```

### 批次大小调优

```
batch_size = pkt_size × send_n

太小：
- 优点：延迟低
- 缺点：CPU开销大，吞吐量低

太大：
- 优点：吞吐量高
- 缺点：延迟增加，内存占用大

推荐范围：256 KB ~ 1 MB
示例：8256 × 64 = 528 KB ✅
```

---

详细使用说明请参考：
- [QUICKSTART.md](QUICKSTART.md)
- [WORKFLOW.md](WORKFLOW.md)
- [BUGFIXES_AND_IMPROVEMENTS.md](BUGFIXES_AND_IMPROVEMENTS.md)
